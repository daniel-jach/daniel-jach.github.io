<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>KED – Erstellung, Erprobung und Analyse eines didaktisch orientierten Korpus für einfaches Deutsch (KED) – Daniel Jach, PhD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Daniel Jach, PhD</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../outreach/index.html"> 
<span class="menu-text">Scholarly Outreach</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/index.html"> 
<span class="menu-text">Teaching Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources/index.html"> 
<span class="menu-text">Digital Ressources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../collaboration/index.html"> 
<span class="menu-text">Community Collaboration</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../photos/index.html"> 
<span class="menu-text">Personal Photographs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../student-work/index.html"> 
<span class="menu-text">Borrowed Plumes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../contact/index.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#überblick" id="toc-überblick" class="nav-link active" data-scroll-target="#überblick">Überblick</a></li>
  <li><a href="#projektbeschreibung" id="toc-projektbeschreibung" class="nav-link" data-scroll-target="#projektbeschreibung">Projektbeschreibung</a></li>
  <li><a href="#literatur" id="toc-literatur" class="nav-link" data-scroll-target="#literatur">Literatur</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">KED – Erstellung, Erprobung und Analyse eines didaktisch orientierten Korpus für einfaches Deutsch (KED)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<style>
.references {
  font-size: 80%;

}
</style>
<section id="überblick" class="level2">
<h2 class="anchored" data-anchor-id="überblick">Überblick</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<tbody>
<tr class="odd">
<td>Laufzeit</td>
<td>seit 01.10.2022</td>
</tr>
<tr class="even">
<td>Projektförderung</td>
<td>Typ-A-Forschungsmittel der Phil-Hist-Fakultät (Universität Augsburg) (für den Zeitraum 01.02.2023 bis 31.12.2023)</td>
</tr>
<tr class="odd">
<td>Projektleitung</td>
<td>PD Dr.&nbsp;Gunther Dietz (Universität Augsburg) &amp; Dr.&nbsp;Daniel Jach (Southwest Jiaotong University, Chengdu)</td>
</tr>
<tr class="even">
<td>Studentische Hilfskraft</td>
<td>Julia Heister</td>
</tr>
</tbody>
</table>
<p>Die Nutzung authentischer Sprachdaten im Rahmen des Data-driven Learning wird als große Chance für die Sprachvermittlung betrachtet. Allerdings fehlen für den DaF- und DaZ-Kontext bislang geeignete nutzerfreundliche Korpora und didaktisch-konzeptionelle Leitlinien.</p>
<p>Im Projekt soll ein Korpus aus bildungssprachlichen Texten in einfachem Deutsch (KED) erstellt, mit einem didaktisch orientierten Web-Interface versehen und empirisch in DDL-basierten Lehr-Lernszenarien für unterschiedliche DaF-/DaZ-Vermittlungssettings erprobt werden.</p>
</section>
<section id="projektbeschreibung" class="level2">
<h2 class="anchored" data-anchor-id="projektbeschreibung">Projektbeschreibung</h2>
<p>Die Verwendung authentischer Sprachdaten im Rahmen des Data-driven Learning (DDL) (Johns 1991) wird als große Chance für die Sprachvermittlung betrachtet. Im Zentrum von DDL-Aktivitäten steht die Auseinandersetzung von Sprachlernenden mit Belegen authentischer Sprachverwendung. Dabei nutzen Lehrende und/oder Lernende umfangreiche digitale Sammlungen authentischer Texte und Gespräche (Korpora). Sie durchsuchen diese computergestützt nach relevanten Zielwörtern und Mustern, die in ihrem unmittelbaren Kontext ausgegeben und geordnet angezeigt werden. Mit Hilfe von DDL-Aktivitäten lassen sich viele als lernwirksam betrachtete Prinzipien wie Lernerautonomie, Authentizität, entdeckendes und problemlösendes Lernen, induktiver Wissenserwerb, Sprachbewusstheit und Gebrauchsbasiertheit verwirklichen (Boulton 2020).</p>
<p>Während datengeleitetes Lernen im Kontext von Englisch als Fremdsprache seit mehr als drei Jahrzehnten theoretisch reflektiert (O’Keefe 2021), unterrichtspraktisch erprobt (Viana 2023) und empirisch validiert wird (Boulton/Cobb 2017), spielt der Ansatz in Theorie und Praxis der DaF- und DaZ-Vermittlung (Ylönen 2012; Wallner 2016, Krekeler 2021, Dietz 2021) bislang keine nennenswerte Rolle. Für die Implementierung von datengeleitetem Lehren und Lernen in der Unterrichtspraxis von Deutsch als Fremd- und Zweitsprache fehlen bislang sowohl geeignete Korpora als auch didaktisch-konzeptionelle Leitlinien.</p>
<p>Auf der Ebene der Korpusressourcen ist auf die Situation zu reagieren, dass die meisten Korpora des Deutschen primär forschungsorientiert und für eine sprachdidaktische Nutzung durch Lehrpersonen oder Lernende in der Regel zu anspruchsvoll sind. Auf der didaktisch-konzeptionellen Ebene geht es um die Entwicklung und Erprobung von DDL-basierten Lehr-Lernszenarien für unterschiedliche DaF-/DaZ-Vermittlungssettings.</p>
<p>Vor diesem Hintergrund soll im Rahmen des KED-Projekts in einem ersten Schritt ein Korpus aus bildungssprachlichen Texten in einfachem Deutsch erstellt werden, die im Internet öffentlich zugänglich sind. Dem liegt die Annahme zugrunde, dass ein Korpus aus Texten in einfacher (authentischer) Sprache für DaF/DaZ-Vermittlungskontexte geeigneter ist als ein Korpus aus Texten, die die ganze Bandbreite bildungssprachlicher Lexik und Strukturen aufweisen. Als Grundlage für die Korpuserstellung dient ein vorhandener Korpus-Prototyp (https://daniel-jach.github.io/simple-german/simple-german.html) (Jach 2022), der um weitere Texte und Textsorten erweitert, mit relevanten Metadaten / Annotierungen und einem didaktisch orientierten, nutzerfreundlichen Web-Interface versehen werden soll.</p>
<p>In einem zweiten Schritt soll das KED-Korpus empirisch hinsichtlich seiner Eignung für die Umsetzung von DDL-Szenarien in der DaF- und DaZ-Vermittlung evaluiert werden. Diese Evaluation umfasst (1) die korpuslinguistische Erfassung sprachlicher Komplexität / Einfachheit des KED-Datenmaterials im Vergleich zu Standardkorpora des Deutschen mittels quantitativer Methoden. Weiterhin sollen (2) nicht nur die Textdaten, sondern auch die Outputs (in Form von Konkordanzlisten) didaktisch motivierter Suchanfragen im KED mit Anfragen in Standardkorpora (DWDS, Corpus Leipzig, DeReKo) verglichen werden. Hierfür kommen sowohl quantitative als auch qualitative Verfahren zum Einsatz. Schließlich ist vorgesehen, (3) die Nutzung des KED in konkreten DDL-basierten Unterrichtssequenzen mittels qualitativer Verfahren zu evaluieren.</p>
<p>Projektleitung: PD Dr.&nbsp;Gunther Dietz (Universität Augsburg | Mail: gunther.dietz(at)uni-a.de) &amp; Dr.&nbsp;Daniel Jach (Southwest Jiaotong University, Chengdu | Mail: daniel.jach(at)outlook.com)</p>
</section>
<section id="literatur" class="level2">
<h2 class="anchored" data-anchor-id="literatur">Literatur</h2>
<div class="references">
<p>Boulton, Alex (2020): “Data-driven learning for younger learners: Obstacles and optimism. Foreword to P. Crosthwaite”. In: Crosthwaite, Peter (Hg.): Data-driven learning for the next generation. Corpora and DDL for pre-tertiary learners. London, New York, NY: Routledge.</p>
<p>Boulton, Alex &amp; Cobb, Tom (2017): Corpus Use in Language Learning: A Meta-Analysis. Language Learning 67: 2, 348–393. https://doi.org/10.1111/lang.12224 .</p>
<p>Dietz, Gunther (2021): “Korpora gesprochener Sprache als Quelle für die Erstellung von Mikro-Hörübungen mit authentischen Hörmaterialien im DaZ-/DaF-Unterricht”. Korpora Deutsch als Fremdsprache 1.1, 97–123. Online: https://kordaf.tujournals.ulb.tu-darmstadt.de/article/id/41/.</p>
<p>Jach, Daniel (2022): “Korpus Einfaches Deutsch. Materialgrundlage für die daten-getriebene Lehre von Deutsch als fremder Bildungssprache auf niedrigem Sprachniveau”. In: Li, Yuan &amp; Liu, Fang &amp; Wang, Zhongxin (Hg.): Didactica, Cultura, Lingua. Perspektiven des Deutschen. München: iudicium, 231–244.</p>
<p>Johns, Tim (1991): “Should you be persuaded. Two samples of data-driven learning materials”. “Classroom Concordancing” (eds.&nbsp;Johns, Tim &amp; King, Philip). In: ELT Journal.4, 1–16. Online: https://lexically.net/wordsmith/corpus_linguistics_links/Tim%20Johns%20and%20DDL.pdf, [Abruf: 22.4.22].</p>
<p>Krekeler, Christian (2021): “Korpustraining und datengestütztes Lernen im Wirtschaftsdeutsch-Unterricht”. Zeitschrift für Interkulturellen Fremdsprachenunterricht 26.1, 161–195. Online: http://tujournals.ulb.tu-darmstadt.de/index.php/zif/, [Abruf: 15.6.22].</p>
<p>O’Keeffe, Anne (2021): “Data-driven learning – a call for a broader research gaze”. Language Teaching 54: 2, 259–272. https://doi.org/10.1017/S0261444820000245.</p>
<p>Viana, Vander (Hrsg.) (2023): Teaching English with Corpora. A Resource Book. London, New York: Routledge.</p>
<p>Wallner, Franziska (2016): “Corpus Literacy im DaF-Studium”. In: Chudak, Sebastian &amp; Drumbl, Hans &amp; Nardi, Antonella &amp; Zanin, Renata (Hg.): Medien in Kommunikation und Unterricht. IDT 2013. Band 6 - Sektionen F2, F3, F4. Bozen/Bolzano: Bolzano University Press, 273–290.</p>
<p>Ylönen, Sabine (2012): “Qualitative und quantitative Methoden datengeleiteten Lernens”. German as a Foreign Language.2-3, 75–113. Online: http://www.gfl-journal.de/2-2012/Ylonen.pdf, [Abruf: 28.6.22].</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/daniel-jach\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>